<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html><head>
    <title>Atomic Operations</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <meta name="generator" content="HeaderDoc" />
<meta name="xcode-display" content="render" />
<style><!--
.toc_contents_text {
    padding-left: 1em;
    text-indent: -1em;
}

ul.tocSubEntryList li.tocSubEntry {
    list-style: none;
}

#colorbox {
		display: none;
}
.spec_sheet_line {
		margin-bottom: 1px;
}
.collapsible {
		display: none;
}
.toc_leadspace {
		width: 10; min-width: 10;
}
.disclosure_triangle_td {
		width: 14; min-width: 14;
		font-size: 10px;
		vertical-align: middle;
}
.specbox td {
		font-size: 13px;
}
.specbox td a {
		font-size: 13px;
}
.specbox td code {
		font-size: 13px;
}
.specbox td tt {
		font-size: 13px;
}
.specbox td pre {
		font-size: 13px;
}
.specbox a {
		font-size: 12px;
}
.disclosure_triangle_td a:hover {
		text-decoration: none;
}
.disclosure_triangle_td a:hover {
		text-decoration: none;
}
.hd_toc_box {
		padding-top: 10px;
		padding-right: 15px;
}.tocSeparator {
		margin-top: 15px;
		padding-bottom: 0px;
		margin-bottom: 0px;
}
.tocSubEntryList {
		margin-left: 0px;
		padding-left: 40px;
		padding-top: 0px;
		margin-top: 2px;
		padding-bottom: 0px;
		margin-bottom: 8px;
}
.hd_toc_heading_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.hd_toc_entry_table {
		margin-top: 2px;
		margin-bottom: 2px;
}
.tocSubEntry {
		margin-left: 0px;
		padding-left: 0px;
		margin-top: 0px;
		margin-bottom: 1px;
}
.tocSubEntry a {
		font-size: 10pt;
}
.tocSubheading {
		padding-left: 14px;
		margin-left: 0px;
		margin-top: 5px;
		padding-top: 0px;
		font-size: 16px;
		color: #808080;
}

#tocMenu {
		border-right: 1px solid #c0c0c0;
		background-color: #f4f4ff;
		top:0px;
		left:0px;
		width:230px;
		height:100%;
}
#bodyContents {
		width: auto;
		padding-left: 15px;
}
--></style>
<script language="JavaScript" type="text/javascript"><!--
function getNewHTTPObject()
{
        var xmlhttp;

        /** Special IE only code ... */
        /*@cc_on
          @if (@_jscript_version >= 5)
              try
              {
                  xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');
              }
              catch (e)
              {
                  try
                  {
                      xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
                  }
                  catch (E)
                  {
                      xmlhttp = false;
                  }
             }
          @else
             xmlhttp = false;
        @end @*/

        /** Every other browser on the planet */
        if (!xmlhttp && typeof XMLHttpRequest != 'undefined')
        {
            try
            {
                xmlhttp = new XMLHttpRequest();
            }
            catch (e)
            {
                xmlhttp = false;
            }
        }

        return xmlhttp;
}

function hidetoc() {
	var toc = document.getElementById('tocMenu');
	var src = toc.getAttribute('src');
	var xhr = getNewHTTPObject();
	xhr.open('GET', src, true);
	xhr.onreadystatechange = function() {
		if(xhr.readyState == 4) {
			var toc = document.getElementById('tocMenu');
			toc.innerHTML = xhr.responseText;
		}
	}
	xhr.send(null);
	var origURL = parent.document.URL;
	var contentURL = origURL.substring(origURL.indexOf('?')+1, origURL.length);
	if (contentURL.length == origURL.length) {
		jumpPos = origURL.substring(origURL.indexOf('#')+1, origURL.length);
	}
	if (contentURL == "hidetoc") {
		var body = document.getElementById('bodyContents');
		if (toc && body) {
			toc.style.display = 'none';
			body.style.marginLeft = '0px';
		}
	}
}

function disclosure_triangle(elt) {
   var linkelt = elt;
   while (elt && elt.tagName != 'TABLE') { elt = elt.parentNode;}
   if (!elt) { return; }
   while (elt && elt.tagName != 'DIV') { elt = elt.nextSibling;}
   if (!elt) { return; }
   if (parseInt(linkelt.getAttribute('state'))) {
      // It's open.  Close it
      linkelt.innerHTML = '&#x25B7;';
      linkelt.setAttribute('state', 0);
      linkelt.setAttribute('class', 'closed_disclosure_triangle');
      elt.style.display = 'none';
   } else {
      // It's closed.  Open it
      linkelt.innerHTML = '&#x25BC;';
      linkelt.setAttribute('state', 1);
      linkelt.setAttribute('class', 'open_disclosure_triangle');
      elt.style.display = 'block';
   }
}
--></script>
<style type="text/css"><!--div {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}td {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}span.hd_tocAccessSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroupSpace { display: block; font-size: 1px; height: 3px; min-height: 3px; }span.hd_tocGroup { display: block; font-weight: bold; font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; margin-left: 0px; padding-left: 40px; }span.hd_tocGroup + span.hd_tocAccess { padding-top: 5px; }td.toc_contents_text {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000; }li.tocSubEntry {font-size: 11pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}p {font-size: 10pt; text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #000000;}a:link {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:visited:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:active {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}a:hover {text-decoration: underline; font-family: lucida grande, geneva, helvetica, arial, sans-serif; color: #36c;}h2.h2tight { margin-top: 0px; padding-top: 0px; }h1 { margin-top: 13px; padding-top: 0px; }h4 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: tiny; font-weight: bold;}h5 {text-decoration: none; font-family: lucida grande, geneva, helvetica, arial, sans-serif; font-size: 10.1pt; font-weight: bold;}pre {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666; font-size: 10pt;}pre a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}pre a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}pre a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}code a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}code a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a { font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt;}tt a:link { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:visited:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:active { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}tt a:hover { font-family: Courier, Consolas, monospace; color: #36c;font-size: 10pt;}body  {text-decoration: none; font-family: Courier, Consolas, monospace; color: #666;font-size: 10pt; padding-left: 0px; padding-top: 0px; margin-left: 0px; margin-top: 0px; border: none; }#hd_outermost_table { margin-left: 0px; border-spacing: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; }#hd_outermost_table > tbody > tr { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-left: 0px; padding-top: 0px; border: none; }#hd_outermost_table > tbody > tr > td { border-spacing: 0px; margin-left: 0px; margin-top: 0px; padding-top: 3px; }.afterName { display: none; }.list_indent { margin-left: 40px; }.declaration_indent { margin-left: 40px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px; padding-bottom: 0px; min-height: 12px; vertical-align: middle; }.declaration_indent pre { margin-top: 20px; padding-top: 0px; margin-bottom: 20px; padding-bottom: 0px; }.gapBeforeFooter { display: none; }hr { height: 0px; min-height: 0px; border-top: none; border-left: none; border-right: none; border-bottom: 1px solid #909090;}hr.afterHeader { display: none }.param_group_indent { margin-left: 25px; }.param_indent { margin-left: 40px; margin-top: 0px; padding-top: 0px; }.param_indent dl { margin-top: 4px; padding-top: 0px; }dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.param_indent dl dd > p:first-child { margin-top: 2px; padding-top: 0px; }.group_indent { margin-left: 40px; }.group_desc_indent { margin-left: 20px; }.warning_indent { margin-left: 40px; }.important_indent { margin-left: 40px; }.note_indent { margin-left: 40px; }h3 {       color: #3C4C6C;}.tight {       margin-top: 2px; margin-bottom: 0px;       padding-top: 0px; padding-bottom: 0px;}h3 a {       color: #3C4C6C;	font-size: 16px;	font-style: normal;	font-variant: normal;	font-weight: bold;	height: 0px;	line-height: normal;}.hd_tocAccess { display: block; margin-left: 40px; font-style: italic; font-size: 10px; font-weight: normal; color: #303030; }.tocSubheading { margin-bottom: 4px; }--></style></head><body bgcolor="#ffffff" onload="hidetoc();" >
<!-- headerDoc=Header;  uid=//apple_ref/doc/header/AtomicUtils.h;   name=Atomic Operations -->
<a name="//apple_ref/doc/header/AtomicUtils.h"></a>
<table id="hd_outermost_table" height="100%" width="100%"><tr><td valign='top' id='tocMenu' src='toc.html'></td>
<td id='bodyContents' valign='top'>
<a name="top"></a>
<h1><a name="AtomicOperations">Atomic Operations</a></h1>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox">
<tr><td scope="row"><b>Includes:</b></td><td><div style="margin-bottom:1px"><div class="content_text"><!-- a logicalPath="//apple_ref/doc/header/CommonServices.h" machineGenerated="true" -->"CommonServices.h"<!-- /a --></div></div></td></tr>
</table></div>
<h2>Introduction</h2>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/doc/header/AtomicUtils.h;name=start --><p>Provides lock-free atomic operations like such as incrementing an integer, compare-and-swap, etc.
<!-- headerDoc=discussion;uid=//apple_ref/doc/header/AtomicUtils.h;name=end --><!-- end discussion -->
<hr class="afterClassOrHeaderInfo"><br><a name='HeaderDoc_groups'><h2 class="h2tight" >Groups</h2></a>

<h3>Atomic Operations</h3>
<div class='group_desc_indent'>
<p><p>Provides lock-free atomic operations like such as incrementing an integer, compare-and-swap, etc.
</p>
</p><h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<p><p>AtomicUtils provides lock-free atomic operations, such as incrementing an integer, compare-and-swap, etc. For many platforms,
this porting has already been done either by implementing hardware/OS-specific code for it or by relying on features of the
compiler to do it (e.g. __sync* builtins from clang/GCC, RAS on NetBSD). If porting is required, the following functions need to
be implemented in an atomic, and ideally lock-free, manner. 
</p>
<p>NOTE: GCC based implementation of these functions are provided.
</p></div>
<h4>Group members:</h4>
<div class='group_indent'>
<dl>
<dt><tt><!-- a logicalPath="//apple_ref/c/func/atomic_add_and_fetch_32" target="_top" machineGenerated="true" -->atomic_add_and_fetch_32<!-- /a --></tt></dt>
<dd></dd>
<dt><tt><!-- a logicalPath="//apple_ref/c/func/atomic_bool_compare_and_swap_32" target="_top" machineGenerated="true" -->atomic_bool_compare_and_swap_32<!-- /a --></tt></dt>
<dd></dd>
<dt><tt><!-- a logicalPath="//apple_ref/c/func/atomic_fetch_and_and_32" target="_top" machineGenerated="true" -->atomic_fetch_and_and_32<!-- /a --></tt></dt>
<dd></dd>
<dt><tt><!-- a logicalPath="//apple_ref/c/func/atomic_fetch_and_or_32" target="_top" machineGenerated="true" -->atomic_fetch_and_or_32<!-- /a --></tt></dt>
<dd></dd>
<dt><tt><!-- a logicalPath="//apple_ref/c/func/atomic_read_write_barrier" target="_top" machineGenerated="true" -->atomic_read_write_barrier<!-- /a --></tt></dt>
<dd></dd>
<dt><tt><!-- a logicalPath="//apple_ref/c/func/atomic_sub_and_fetch_32" target="_top" machineGenerated="true" -->atomic_sub_and_fetch_32<!-- /a --></tt></dt>
<dd></dd>
<dt><tt><!-- a logicalPath="//apple_ref/c/func/atomic_val_compare_and_swap_32" target="_top" machineGenerated="true" -->atomic_val_compare_and_swap_32<!-- /a --></tt></dt>
<dd></dd>
<dt><tt><!-- a logicalPath="//apple_ref/c/func/atomic_yield" target="_top" machineGenerated="true" -->atomic_yield<!-- /a --></tt></dt>
<dd></dd>
</dl>
</div>
<hr class="afterGroupHeading"><a name="HeaderDoc_functions"></a>
<h2 class="h2tight">Functions</h2>
<dl>
<dt><tt><a href="index.html#//apple_ref/c/func/atomic_add_and_fetch_32" target="_top">atomic_add_and_fetch_32</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/atomic_bool_compare_and_swap_32" target="_top">atomic_bool_compare_and_swap_32</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/atomic_fetch_and_and_32" target="_top">atomic_fetch_and_and_32</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/atomic_fetch_and_or_32" target="_top">atomic_fetch_and_or_32</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/atomic_read_write_barrier" target="_top">atomic_read_write_barrier</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/atomic_sub_and_fetch_32" target="_top">atomic_sub_and_fetch_32</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/atomic_val_compare_and_swap_32" target="_top">atomic_val_compare_and_swap_32</a></tt></dt>
<dd></dd>
<dt><tt><a href="index.html#//apple_ref/c/func/atomic_yield" target="_top">atomic_yield</a></tt></dt>
<dd></dd>
</dl>
<hr class="betweenAPIEntries"><!-- headerDoc=func;  uid=//apple_ref/c/func/atomic_add_and_fetch_32;   name=atomic_add_and_fetch_32 -->
<a name="//apple_ref/c/func/atomic_add_and_fetch_32"></a>
<h3><a name="atomic_add_and_fetch_32">atomic_add_and_fetch_32</a></h3>
<hr class="afterName"><div class='declaration_indent'>
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_add_and_fetch_32;name=start --><!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/instm/atomic_add_and_fetch_32 //apple_ref/c/clm/atomic_add_and_fetch_32 //apple_ref/c/intfcm/atomic_add_and_fetch_32 //apple_ref/c/intfm/atomic_add_and_fetch_32 //apple_ref/c/func/atomic_add_and_fetch_32 //apple_ref/c/ftmplt/atomic_add_and_fetch_32 //apple_ref/c/defn/atomic_add_and_fetch_32 //apple_ref/c/macro/atomic_add_and_fetch_32 //apple_ref/doc/anysymbol/atomic_add_and_fetch_32" machineGenerated="true" --><span class="function">atomic_add_and_fetch_32</span><!-- /a -->(
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="type">*</span><span class="param">inPtr</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">inVal</span> );  <!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_add_and_fetch_32;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_add_and_fetch_32;name=start --><p>This function atomically adds the value of inVal to the variable that inPtr points to. The result is stored in the address that
is specified by inPtr. 
</p>
<p>i.e. { *inPtr += inVal; return *inPtr; }
</p>
<p>NOTE: GCC based implementation of this function is provided. If porting is required, the following functions need to
be implemented in an atomic, and ideally lock-free, manner. 
<!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_add_and_fetch_32;name=end --><!-- end discussion -->
<hr class="betweenAPIEntries"><!-- headerDoc=func;  uid=//apple_ref/c/func/atomic_bool_compare_and_swap_32;   name=atomic_bool_compare_and_swap_32 -->
<a name="//apple_ref/c/func/atomic_bool_compare_and_swap_32"></a>
<h3><a name="atomic_bool_compare_and_swap_32">atomic_bool_compare_and_swap_32</a></h3>
<hr class="afterName"><div class='declaration_indent'>
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_bool_compare_and_swap_32;name=start --><!-- a logicalPath="//apple_ref/c/cl/Boolean //apple_ref/c/tdef/Boolean //apple_ref/c/tag/Boolean //apple_ref/c/struct/Boolean //apple_ref/c/intf/Boolean //apple_ref/doc/anysymbol/Boolean" machineGenerated="true" --><span class="type">Boolean</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/instm/atomic_bool_compare_and_swap_32 //apple_ref/c/clm/atomic_bool_compare_and_swap_32 //apple_ref/c/intfcm/atomic_bool_compare_and_swap_32 //apple_ref/c/intfm/atomic_bool_compare_and_swap_32 //apple_ref/c/func/atomic_bool_compare_and_swap_32 //apple_ref/c/ftmplt/atomic_bool_compare_and_swap_32 //apple_ref/c/defn/atomic_bool_compare_and_swap_32 //apple_ref/c/macro/atomic_bool_compare_and_swap_32 //apple_ref/doc/anysymbol/atomic_bool_compare_and_swap_32" machineGenerated="true" --><span class="function">atomic_bool_compare_and_swap_32</span><!-- /a -->(
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="type">*</span><span class="param">inPtr</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">inOldValue</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">inNewValue</span> );  <!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_bool_compare_and_swap_32;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_bool_compare_and_swap_32;name=start --><p>This function compares the value of inOldValue with the value of the variable that inPtr points to. If they are equal, the value
of inNewValue is stored in the address that is specified by inPtr; otherwise, no operation is performed. If the value of
inOldValue and the value of the variable that inPtr points to are equal, the function returns true, otherwise it returns false.
</p>
<p>i.e.  { if( *inPtr == inOldValue ) { *inPtr = inNewValue; return 1; } else return 0; }
</p>
<p>NOTE: GCC based implementation of this function is provided. If porting is required, the following functions need to
be implemented in an atomic, and ideally lock-free, manner. 
<!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_bool_compare_and_swap_32;name=end --><!-- end discussion -->
<hr class="betweenAPIEntries"><!-- headerDoc=func;  uid=//apple_ref/c/func/atomic_fetch_and_and_32;   name=atomic_fetch_and_and_32 -->
<a name="//apple_ref/c/func/atomic_fetch_and_and_32"></a>
<h3><a name="atomic_fetch_and_and_32">atomic_fetch_and_and_32</a></h3>
<hr class="afterName"><div class='declaration_indent'>
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_fetch_and_and_32;name=start --><!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/instm/atomic_fetch_and_and_32 //apple_ref/c/clm/atomic_fetch_and_and_32 //apple_ref/c/intfcm/atomic_fetch_and_and_32 //apple_ref/c/intfm/atomic_fetch_and_and_32 //apple_ref/c/func/atomic_fetch_and_and_32 //apple_ref/c/ftmplt/atomic_fetch_and_and_32 //apple_ref/c/defn/atomic_fetch_and_and_32 //apple_ref/c/macro/atomic_fetch_and_and_32 //apple_ref/doc/anysymbol/atomic_fetch_and_and_32" machineGenerated="true" --><span class="function">atomic_fetch_and_and_32</span><!-- /a -->(
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="type">*</span><span class="param">inPtr</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">inVal</span> );  <!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_fetch_and_and_32;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_fetch_and_and_32;name=start --><p>This function performs an atomic bitwise OR operation on the variable inVal with the variable that inPtr points to. The result
is stored in the address that is specified by inPtr. The function returns the initial value of the variable that inPtr points to.
</p>
<p>i.e. { tmp = *inPtr; *inPtr &= inVal; return tmp; }
</p>
<p>NOTE: GCC based implementation of this function is provided. If porting is required, the following functions need to
be implemented in an atomic, and ideally lock-free, manner. 
<!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_fetch_and_and_32;name=end --><!-- end discussion -->
<hr class="betweenAPIEntries"><!-- headerDoc=func;  uid=//apple_ref/c/func/atomic_fetch_and_or_32;   name=atomic_fetch_and_or_32 -->
<a name="//apple_ref/c/func/atomic_fetch_and_or_32"></a>
<h3><a name="atomic_fetch_and_or_32">atomic_fetch_and_or_32</a></h3>
<hr class="afterName"><div class='declaration_indent'>
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_fetch_and_or_32;name=start --><!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/instm/atomic_fetch_and_or_32 //apple_ref/c/clm/atomic_fetch_and_or_32 //apple_ref/c/intfcm/atomic_fetch_and_or_32 //apple_ref/c/intfm/atomic_fetch_and_or_32 //apple_ref/c/func/atomic_fetch_and_or_32 //apple_ref/c/ftmplt/atomic_fetch_and_or_32 //apple_ref/c/defn/atomic_fetch_and_or_32 //apple_ref/c/macro/atomic_fetch_and_or_32 //apple_ref/doc/anysymbol/atomic_fetch_and_or_32" machineGenerated="true" --><span class="function">atomic_fetch_and_or_32</span><!-- /a -->(
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="type">*</span><span class="param">inPtr</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">inVal</span> );  <!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_fetch_and_or_32;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_fetch_and_or_32;name=start --><p>This function atomically adds the value of inVal to the variable that inPtr points to. The result is stored in the address that
is specified by inPtr. The function returns the initial value of the variable that inPtr points to.
</p>
<p>i.e. { tmp = *inPtr; *inPtr |= inVal; return tmp; }
</p>
<p>NOTE: GCC based implementation of this function is provided. If porting is required, the following functions need to
be implemented in an atomic, and ideally lock-free, manner. 
<!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_fetch_and_or_32;name=end --><!-- end discussion -->
<hr class="betweenAPIEntries"><!-- headerDoc=func;  uid=//apple_ref/c/func/atomic_read_write_barrier;   name=atomic_read_write_barrier -->
<a name="//apple_ref/c/func/atomic_read_write_barrier"></a>
<h3><a name="atomic_read_write_barrier">atomic_read_write_barrier</a></h3>
<hr class="afterName"><div class='declaration_indent'>
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_read_write_barrier;name=start --><!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/instm/atomic_read_write_barrier //apple_ref/c/clm/atomic_read_write_barrier //apple_ref/c/intfcm/atomic_read_write_barrier //apple_ref/c/intfm/atomic_read_write_barrier //apple_ref/c/func/atomic_read_write_barrier //apple_ref/c/ftmplt/atomic_read_write_barrier //apple_ref/c/defn/atomic_read_write_barrier //apple_ref/c/macro/atomic_read_write_barrier //apple_ref/doc/anysymbol/atomic_read_write_barrier" machineGenerated="true" --><span class="function">atomic_read_write_barrier</span><!-- /a -->(
    <span class="param">void</span> );  <!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_read_write_barrier;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_read_write_barrier;name=start --><p>This function ensures reads and writes before this line have completed.
</p>
<!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_read_write_barrier;name=end --><!-- end discussion -->
<hr class="betweenAPIEntries"><!-- headerDoc=func;  uid=//apple_ref/c/func/atomic_sub_and_fetch_32;   name=atomic_sub_and_fetch_32 -->
<a name="//apple_ref/c/func/atomic_sub_and_fetch_32"></a>
<h3><a name="atomic_sub_and_fetch_32">atomic_sub_and_fetch_32</a></h3>
<hr class="afterName"><div class='declaration_indent'>
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_sub_and_fetch_32;name=start --><!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/instm/atomic_sub_and_fetch_32 //apple_ref/c/clm/atomic_sub_and_fetch_32 //apple_ref/c/intfcm/atomic_sub_and_fetch_32 //apple_ref/c/intfm/atomic_sub_and_fetch_32 //apple_ref/c/func/atomic_sub_and_fetch_32 //apple_ref/c/ftmplt/atomic_sub_and_fetch_32 //apple_ref/c/defn/atomic_sub_and_fetch_32 //apple_ref/c/macro/atomic_sub_and_fetch_32 //apple_ref/doc/anysymbol/atomic_sub_and_fetch_32" machineGenerated="true" --><span class="function">atomic_sub_and_fetch_32</span><!-- /a -->(
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="type">*</span><span class="param">inPtr</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">inVal</span> );  <!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_sub_and_fetch_32;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_sub_and_fetch_32;name=start --><p>This function atomically subtracts the value of inVal from the variable that inPtr points to. The result is stored in the
address that is specified by inPtr. The function returns the new value of the variable that inPtr points to.
</p>
<p>i.e. { *inPtr -= inVal; return *inPtr; }
</p>
<p>NOTE: GCC based implementation of this function is provided. If porting is required, the following functions need to
be implemented in an atomic, and ideally lock-free, manner. 
<!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_sub_and_fetch_32;name=end --><!-- end discussion -->
<hr class="betweenAPIEntries"><!-- headerDoc=func;  uid=//apple_ref/c/func/atomic_val_compare_and_swap_32;   name=atomic_val_compare_and_swap_32 -->
<a name="//apple_ref/c/func/atomic_val_compare_and_swap_32"></a>
<h3><a name="atomic_val_compare_and_swap_32">atomic_val_compare_and_swap_32</a></h3>
<hr class="afterName"><div class='declaration_indent'>
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_val_compare_and_swap_32;name=start --><!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/instm/atomic_val_compare_and_swap_32 //apple_ref/c/clm/atomic_val_compare_and_swap_32 //apple_ref/c/intfcm/atomic_val_compare_and_swap_32 //apple_ref/c/intfm/atomic_val_compare_and_swap_32 //apple_ref/c/func/atomic_val_compare_and_swap_32 //apple_ref/c/ftmplt/atomic_val_compare_and_swap_32 //apple_ref/c/defn/atomic_val_compare_and_swap_32 //apple_ref/c/macro/atomic_val_compare_and_swap_32 //apple_ref/doc/anysymbol/atomic_val_compare_and_swap_32" machineGenerated="true" --><span class="function">atomic_val_compare_and_swap_32</span><!-- /a -->(
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="type">*</span><span class="param">inPtr</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">inOldValue</span>,
    <!-- a logicalPath="//apple_ref/c/cl/int32_t //apple_ref/c/tdef/int32_t //apple_ref/c/tag/int32_t //apple_ref/c/struct/int32_t //apple_ref/c/intf/int32_t //apple_ref/doc/anysymbol/int32_t" machineGenerated="true" --><span class="type">int32_t</span><!-- /a --> <span class="param">inNewValue</span> );  <!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_val_compare_and_swap_32;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_val_compare_and_swap_32;name=start --><p>This function compares the value of inOldValue to the value of the variable that inPtr points to. If they are equal, the value
of inNewValue is stored in the address that is specified by inPtr, otherwise, no operation is performed. The function returns
the initial value of the variable that inPtr points to.
</p>
<p>i.e. { if( *inPtr == inOldValue ) { *inPtr = inNewValue; return inOldValue; } else return *inPtr; }
</p>
<p>NOTE: GCC based implementation of this function is provided. If porting is required, the following functions need to
be implemented in an atomic, and ideally lock-free, manner. 
<!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_val_compare_and_swap_32;name=end --><!-- end discussion -->
<hr class="betweenAPIEntries"><!-- headerDoc=func;  uid=//apple_ref/c/func/atomic_yield;   name=atomic_yield -->
<a name="//apple_ref/c/func/atomic_yield"></a>
<h3><a name="atomic_yield">atomic_yield</a></h3>
<hr class="afterName"><div class='declaration_indent'>
<pre><!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_yield;name=start --><!-- a logicalPath="//apple_ref/c/cl/void //apple_ref/c/tdef/void //apple_ref/c/tag/void //apple_ref/c/struct/void //apple_ref/c/intf/void //apple_ref/doc/anysymbol/void" machineGenerated="true" --><span class="type">void</span><!-- /a --> <!-- a logicalPath="//apple_ref/c/instm/atomic_yield //apple_ref/c/clm/atomic_yield //apple_ref/c/intfcm/atomic_yield //apple_ref/c/intfm/atomic_yield //apple_ref/c/func/atomic_yield //apple_ref/c/ftmplt/atomic_yield //apple_ref/c/defn/atomic_yield //apple_ref/c/macro/atomic_yield //apple_ref/doc/anysymbol/atomic_yield" machineGenerated="true" --><span class="function">atomic_yield</span><!-- /a -->(
    <span class="param">void</span> );  <!-- headerDoc=declaration;uid=//apple_ref/c/func/atomic_yield;name=end --></pre>
</div>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Discussion</font></h5>
<!-- begin discussion --><!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_yield;name=start --><p>This function yields the current thread to allow other threads to execute.
<!-- headerDoc=discussion;uid=//apple_ref/c/func/atomic_yield;name=end --><!-- end discussion -->
<p class="gapBeforeFooter">&nbsp;</p><hr class="afterFooter"><div class="hd_copyright_and_timestamp">
<p class="hd_timestamp">Last Updated: August 21, 2013
</p></div>
</td></tr></table>
</body></html>
